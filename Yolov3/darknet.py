# -*- coding: utf-8 -*-
"""Darknet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tPxaH4c-m0BxMItJGPMuTpiKi-AZJqiS
"""

from __future__ import division

import torch 
import torch.nn as nn
import torch.nn.functional as F
from torch.autograd import Variable
import numpy as np
!wget https://raw.githubusercontent.com/pjreddie/darknet/master/cfg/yolov3.cfg

def parse_cfg(cfg_file):
  file=open(cfg_file,'r')
  lines=file.read().split('\n')
  lines=[x.rstrip().lstrip() for x in lines if len(x)>0 and x[0]!='#']
  block={}
  blocks=[]
  for line in lines:
    if line[0]=='[':
      if len(block)!=0:
        blocks.append(block)
        block={}
      block['type']=line[1:-1].rstrip()
    else:
      key,value=line.split('=')
      block[key.rstrip()]=value.lstrip()
  blocks.append(block)
  return blocks

class EmptyLayer(nn.Module):
  def __init__(self):
    super(EmptyLayer,self).__init__()
class DetectionLayer(nn.Module):
    def __init__(self, anchors):
        super(DetectionLayer, self).__init__()
        self.anchors = anchors

def create_modules(blocks):
  net_info=blocks[0]
  module_list=nn.ModuleList()
  prev_filters=3
  output_filters=[]
  for index,x in enumerate(blocks[1:]):
    module=nn.Sequential()
    if x['type']=='convolution':
        activation=x['activation']
        try:
          batch_normalize=int(x['batch_normalize'])
          bias=False
        except:
          batch_normalize=0
          bias=True
        filters= int(x['filters'])
        stride= int(x['stride'])
        kernel_size= int(x['size'])
        padding= int(x['pad'])
        if padding:
          pad=(filters-1)//2
        else:
          pad=0

        conv= nn.Conv2d(prev_filters,filters,kernel_size,stride,pad,bias=bias)
        module.add_module('conv_{0}'.format(index),conv) 

        if batch_normalize:
          bn=nn.BatchNorm2d(filters)
          module.add_module('batch_norm_{0}'.format(index),bn)

        if activation=='leaky':
          activ=nn.leakyReLU(0.1,inplace=True)
          module.add_module('leaky_{0}'.format(index),activ)
    
    elif (x['type']=='upsample'):
      stride=int(x['stride'])
      upsample=nn.Upsample(scale_factor=2,mode='bilinear')
      module.add_module('upsample_{}'.format(index),upsample)
    
    elif (x['type']=='route'):
        x['layers'] = x['layers'].split(',')

        start= int(x['layers'][0])

        try:
          end=int(x['layers'][1])
        except:
          end=0

        if start>0:
           start=start-index 
        else:
          end=end-index    

        route=EmptyLayer()
        module.add_module("route_{0}".format(index), route)

        if end<0:
          filters= output_filters[index+start]+output_filters[index+end]
        else:
          filters= output_filters[index+start] 
     
    elif (x['type']=='shortcut'):
       shortcut=EmptyLayer()
       model.add_module("shortcut_{}".format(index), shortcut)

    elif (x['type']=='yolo'):
       mask= x['mask'].split(',')
       mask=[int(x) for x in mask]

       anchors=x['anchors'].split(',')
       anchors=[int(a) for a in anchors]
       anchors = [(anchors[i], anchors[i+1]) for i in range(0, len(anchors),2)]
       anchors = [anchors[i] for i in mask]

       detection = DetectionLayer(anchors)
       module.add_module("Detection_{}".format(index), detection) 
    module_list.append(module)
    prev_filters = filters
    output_filters.append(filters)              
  return (net_info, module_list)

class Darknet(nn.Module):
  def __init__(self,cfgfile):
    super(Darknet,self).__init__()
    self.blocks=parse_cfg(cfgfile)
    self.net_info,self.module_list=create_modules(blocks)
  def forward(self,x,CUDA):
    modules=self.blocks[1:]
    outputs={}  
    for i,module in enumerate(modules):
      module_type=(module['type'])
      if module_type=='convolutional' or module_type=='upsample':
        x=self.module_type[i](x)
      elif module_type=='route':
        layers=self.module['layers']
        layers=[int(layer) for layer in layers]

        if (layers[0]>0):
          layers[0]=layers[0]-i
        if len(layers)==1:
          x=outputs[i+layers[0]]
        else:
          if (layers[1]>0):
            layers[1]=layers[1]-i 

          map1=outputs[i+layers[0]]
          map2=outputs[i+layers[1]]

          x=torch.cat((map1,map2),axis=1)
      elif module_type=='shortcut':
        from_= int(module['from'])
        x=outputs[i-1] +outputs[i+from_]

